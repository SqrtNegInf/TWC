#!/usr/bin/env perl
use v5.36;

use Carp qw(croak);
use Scalar::Util qw(looks_like_number);

say power_of_two($_) ? 1 : 0 for 8, 15, 125;

sub power_of_two ($n ) {

    # edge case
    # a = 1, b = 2, a ^ b = 1 = $n
    return 1 if $n == 1;

    # calculate sqrt as upper bound and check if $n is a quadratic number
    # $floored_sqrt ^ 2 = $n
    my $sqrt         = sqrt($n);
    my $floored_sqrt = int($sqrt);
    return 1 if $floored_sqrt == $sqrt;

    # n  = a ^ b
    # log'a(n) = b
    # for bases(a) from 2 to $floored_sqrt, check if we can find an integer
    # exponent (b) so that a ^ b = $n
    return generator_any(
        sub($a) {
            my $maybe_b = logarithm( $a, $n );
            if ( int($maybe_b) == $maybe_b ) {
                say "FOUND: $a ^ $maybe_b = $n" if $ENV{DEBUG};
                return 1;
            }
        },
        mk_number_gen( 2, $floored_sqrt )
    );
}

#            log'a(x)
# log'b(x) = ------
#            log'a(b)
sub logarithm ( $base, $numerus ) {
    return $numerus == 1 ? 1 : croak "cannot calculate log'$base($numerus)"
      if $base == 1;
    return log($numerus) / log($base);
}

# check wether any of the values generated by $gen fullfills $cond
# exhausts the generator up to the first value that fullfills $cond
sub generator_any ( $cond, $gen ) {
    for ( my $n = $gen->() ; defined($n) ; $n = $gen->() ) {
        return 1 if $cond->($n);
    }
}

# lazily generate a stream of numbers from $start to $end
# returns a sub ref that can be called to generate the next value until
# exhaustion. when the generator is exhausted `undef` will be returned on each
# subsequent call
sub mk_number_gen ( $start, $end ) {
    return sub {
        state $cur = $start;
        return $cur <= $end ? $cur++ : undef;
    };
}
