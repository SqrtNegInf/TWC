#!/usr/bin/env perl
use v5.36;

###############################################################################
=comment

Perl Weekly Challenge 096
=========================

Task #2
-------
*Edit Distance*

Submitted by: Mohammad S Anwar

You are given two strings $S1 and $S2.

Write a script to find out the minimum operations required to convert $S1 into
$S2. The operations can be insert, remove or replace a character. Please check
out [https://en.wikipedia.org/wiki/Edit_distance |Wikipedia] page for more in-
formation.

Example 1:

 Input: $S1 = "kitten"; $S2 = "sitting"
 Output: 3

 Operation 1: replace 'k' with 's'
 Operation 2: replace 'e' with 'i'
 Operation 3: insert 'g' at the end

Example 2:

 Input: $S1 = "sunday"; $S2 = "monday"
 Output: 2

 Operation 1: replace 's' with 'm'
 Operation 2: replace 'u' with 'o'

=cut
###############################################################################

#--------------------------------------#
# Copyright © 2021 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
=comment

Since the allowable operations are given as "insert, remove or replace a
character", we may assume that the edit distance required in this Task is the
Levenshtein distance.

A single insert, remove, or replace operation is assigned a cost of one. To
determine the minimum overall cost, the dynamic-programming Wagner-Fischer
algorithm is used. A Matrix class is provided to facilitate implementation of
the algorithm.

The Wagner-Fischer algorithm is not the fastest, but it does create a full
matrix which can then be used to reconstruct the changes by which the first
string has been transformed into the second. If the $EXPLAIN constant below is
set to a true value, the minimum operations required to transform $S1 into $S2
are listed in the output below the Levenshtein distance. If both $EXPLAIN and
$SHOW_MATRIX are set to true values, the matrix generated by the Wagner-Fischer
algorithm is also displayed.

=cut
#==============================================================================

use strict;
use warnings;
use Const::Fast;


###############################################################################
=comment

Perl Weekly Challenge 096, Task #2: Edit Distance

Matrix class for use in implementing the Wagner–Fischer algorithm for finding
the Levenshtein distance between two strings.

=cut
###############################################################################

#--------------------------------------#
# Copyright © 2021 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
{
package Matrix;
#==============================================================================

use strict;
use warnings;

#------------------------------------------------------------------------------
sub new                                                           # Constructor
#------------------------------------------------------------------------------
{
    my ($class, $word1, $word2) = @_;

    my  $cols = length( $word1 ) + 1;
    my  $rows = length( $word2 ) + 1;
    my  @matrix;

    for my $row (0 .. $rows)
    {
        $matrix[ $row ][ $_ ] = undef for 0 .. $cols;
    }

    $word2 = "#$word2";
    my $i  = 0;

    for my $row (1 .. $rows)
    {
        $matrix[ $row ][ 0 ] = substr $word2, $i, 1;
        $matrix[ $row ][ 1 ] = $i++;
    }

    $word1 = "#$word1";
    $i     = 0;

    for my $col (1 .. $cols)
    {
        $matrix[ 0 ][ $col ] = substr $word1, $i, 1;
        $matrix[ 1 ][ $col ] = $i++;
    }

    my %self = (
                   height =>  $rows,
                   width  =>  $cols,
                   matrix => \@matrix,
               );

    return bless \%self, $class;
}

#------------------------------------------------------------------------------
sub height                                              # Accessor: getter only
#------------------------------------------------------------------------------
{
    my ($self) = @_;

    return $self->{height};
}

#------------------------------------------------------------------------------
sub width                                               # Accessor: getter only
#------------------------------------------------------------------------------
{
    my ($self) = @_;

    return $self->{width};
}

#------------------------------------------------------------------------------
sub element                                       # Accessor: getter and setter
#------------------------------------------------------------------------------
{
    my ($self, $row, $col, $value) = @_;

    if (defined $value)
    {
        $self->{matrix}[ $row + 1 ][ $col + 1 ] = $value;       # Set
    }

    return $self->{matrix}[ $row + 1 ][ $col + 1 ];             # Get
}

#------------------------------------------------------------------------------
sub display
#------------------------------------------------------------------------------
{
    my ($self)  = @_;
    my  $height = $self->{height};
    my  $width  = $self->{width};

    # Pre-compute the maximum widths of individual columns

    my @widths = ( 1 );

    for my $col (1 .. $width)
    {
        my $max = 0;

        for my $row (1 .. $height)
        {
            my $current = $self->{matrix}[ $row ][ $col ];
            my $cur_len = length $current;
               $max     = $cur_len if $cur_len > $max;
        }

        $widths[$col] = $max;
    }

    # Draw a vertical separator

    my $line  = '+';
       $line .=  sprintf '-%s-+', '-'  x $widths[ $_ ] for 0 .. $width;
       $line .= "\n";

    # Draw the matrix

    my $display = $line;

    for my $row (0 .. $height)
    {
        $display .= '|';
        $display .=  sprintf ' %*s |', $widths[ $_ ],
                                       $self->{matrix}[ $row ][ $_ ] // ' '
                        for 0 .. $width;
        $display .= "\n" . $line;
    }

    return $display;
}

###############################################################################
1;
###############################################################################
}

const my $EXPLAIN     => 1;
const my $SHOW_MATRIX => 0;
const my $USAGE       =>
"Usage:
  perl $0 <S1> <S2>

    <S1>    First string
    <S2>    Second string\n";

#------------------------------------------------------------------------------
BEGIN
#------------------------------------------------------------------------------
{
    #$| = 1;
    #print "\nChallenge 096, Task #2: Edit Distance (Perl)\n\n";
}

#==============================================================================
MAIN:
#==============================================================================
{
    my ($S1, $S2) = ('kitten', 'sitting'); #parse_command_line();

    printf qq[Input:  \$S1 = "%s"; \$S2 = "%s"\n], $S1, $S2;

    my ($distance, $matrix) = levenshtein_distance($S1, $S2);

    printf qq[Output: %d (Levenshtein distance)\n], $distance;

    if ($EXPLAIN)
    {
        print "\n", $matrix->display if $SHOW_MATRIX;

        my $path = trace_path($matrix);
        my $ops  = find_operations($path, $S1, $S2);

        print "\n$ops" if $ops;
    }
}

#------------------------------------------------------------------------------
sub levenshtein_distance
#------------------------------------------------------------------------------
{
    my ($s, $t) = @_;
    my  $matrix = Matrix->new($s, $t);
    my  @s      = ('#', split //, $s);
    my  @t      = ('#', split //, $t);

    for my $row (1 .. $#t)
    {
        for my $col (1 .. $#s)
        {
            my $del_cost = $matrix->element($row - 1, $col    ) + 1;
            my $ins_cost = $matrix->element($row,     $col - 1) + 1;
            my $sub_cost = $matrix->element($row - 1, $col - 1) +
                               (($t[ $row ] eq $s[ $col ]) ? 0  : 1);

            $matrix->element($row, $col, min($del_cost, $ins_cost, $sub_cost));
        }
    }

    return ($matrix->element($#t, $#s), $matrix);
}

#------------------------------------------------------------------------------
sub trace_path
#------------------------------------------------------------------------------
{
    my ($matrix) = @_;
    my  $row     = $matrix->height - 1;
    my  $col     = $matrix->width  - 1;
    my  $min     = $matrix->element($row, $col);
    my  @path    = [ $row, $col, $min ];

    until ($row == 0 && $col == 0)
    {
        if    ($col == 0)
        {
            $min = $matrix->element(--$row,   $col);        # Move up:   insert
        }
        elsif ($row == 0)
        {
            $min = $matrix->element(  $row, --$col);        # Move left: delete
        }
        else
        {
            my $up   = $matrix->element($row - 1, $col    );
            my $left = $matrix->element($row,     $col - 1);
            my $diag = $matrix->element($row - 1, $col - 1);

            if    ($diag <= $up   && $diag <= $left)
            {                                               # Move up and left:
                $min = $matrix->element(--$row, --$col);    #           replace
            }
            elsif ($up   <= $diag && $up   <= $left)
            {
                $min = $matrix->element(--$row,   $col);    # Move up:   insert
            }
            else
            {
                $min = $matrix->element(  $row, --$col);    # Move left: delete
            }
        }

        push @path, [ $row, $col, $min ];
    }

    return [ reverse @path ];
}

#------------------------------------------------------------------------------
sub find_operations
#------------------------------------------------------------------------------
{
    my ($path, $s, $t) = @_;
    my  $summary       = '';
    my  $last          = shift @$path;
    my  $count         = 0;

    while (my $next = shift @$path)
    {
        if ($next->[2] > $last->[2])
        {
            my  $op;

            if    ($next->[0] == $last->[0])
            {
                $op = sprintf "remove '%s'",
                               substr($s, $next->[1] - 1, 1);
            }
            elsif ($next->[1] == $last->[1])
            {
                $op = sprintf "insert '%s'",
                               substr($t, $next->[0] - 1, 1);
            }
            else
            {
                $op = sprintf "replace '%s' with '%s'",
                               substr($s, $next->[1] - 1, 1),
                               substr($t, $next->[0] - 1, 1);
            }

            $summary .= sprintf "Operation %d: %s\n", ++$count, $op;
        }

        $last = $next;
    }

    return $summary;
}

#------------------------------------------------------------------------------
sub min
#------------------------------------------------------------------------------
{
    my ($x, $y, $z) = @_;

    my  $min = $x;
        $min = $y if $y < $min;
        $min = $z if $z < $min;

    return $min;
}

#------------------------------------------------------------------------------
sub parse_command_line
#------------------------------------------------------------------------------
{
    my $args = scalar @ARGV;

    if    ($args < 2)
    {
        die "ERROR: Too few command-line arguments\n$USAGE";
    }
    elsif ($args > 2)
    {
        die "ERROR: Too many command-line arguments\n$USAGE";
    }

    return @ARGV[ 0 .. 1 ];
}

###############################################################################
